completeExpression
  = whitespace e:expression "" { return e; }

expression
  = lambda openParens a:label colon b:expression closeParens arrow c:expression
    {
      return {
        type: "Lambda",
        args: [ a, b, c ]
      };
    }
  / if a:expression then b:expression else c:expression
    {
      return {
        type: "If",
        args: [ a, b, c ]
      }
    }
  / let a:label b:(colon t:expression { return t; })? equal c:expression in d:expression
    {
      return {
        type: "Let",
        args: [a, b, c,d]
      }
    }
  / forall openParens a:label colon b:expression closeParens arrow c:expression
    {
      return {
        type: "Forall",
        args: [a, b, c]
      }
    }
  / operatorExpression arrow expression
  / annotatedExpression

annotatedExpression
  = merge a:selectorExpression b:selectorExpression (colon applicationExpression)?
    {
      return {
        type: "Merge",
        args: [a, b]
      }
    }
  / openBracket (emptyCollection / nonEmptyOptional)
  / a:operatorExpression t:(colon t:expression { return t; })?
    {
      if (t) {
        return {
          type: "Annotate",
          args: [ a,t ]
        }
      } else {
        return a;
      }
    }


emptyCollection
  = closeBracket colon (List / Optional) selectorExpression

nonEmptyOptional
  = expression closeBracket colon Optional selectorExpression

List
  = "List" whitespace
  
Optional
  = "Optional" whitespace

lambda
  = [\\λ] whitespace

openParens
  = [(] whitespace

quotedLabel
  = (ALPHA / DIGIT / [\-/_:.])+

label
  = ("`" quotedLabel "`" / l:simpleLabel) whitespace

colon
  = [:] whitespace

closeParens
  = [)] whitespace

arrow
  = ("->" / "→") whitespace

whitespace
  = whitespaceChunk*

simpleLabel
  = !reserved
    x:(ALPHA / "_") xs:(ALPHA / DIGIT / [-/_])*
    { return x + xs.join(''); }

reserved
  = "let" / "in"

whitespaceChunk
  = [ ]
  / endOfLine
  / lineComment
  / blockComment

blockComment
  = "{-" blockCommentContinue

blockCommentContinue
  = "-}" / blockCommentChunk blockCommentContinue

blockCommentChunk
  = blockComment
  / tab
  / endOfLine
  / .

tab = "\t"

ALPHA
  = [a-zA-Z]

DIGIT
  = [0-9]

prefer
  = ("⫽" / "//") whitespace

listAppend
  = "#" whitespace

operatorExpression
  = orExpression

orExpression
  = plusExpression (or plusExpression)*

plusExpression
  = textAppendExpression (plus listAppendExpression)*

textAppendExpression
  = listAppendExpression (textAppend listAppendExpression)*

listAppendExpression
  = andExpression (listAppend andExpression)*

andExpression
  = combineExpression (and combineExpression)*
  
combineExpression
  = preferExpression (combine preferExpression)*

preferExpression =
  e:timesExpression prefers:(prefer timesExpression)*

timesExpression =
  e:equalExpression prefers:(times equalExpression)*

equalExpression =
  e:notEqualExpression prefers:(doubleEqual notEqualExpression)*

notEqualExpression =
  e:applicationExpression prefers:(notEqual applicationExpression)*

applicationExpression
  = c:constructors? args:selectorExpression+

constructors
  = "constructors" whitespace

selectorExpression
  = e:primitiveExpression path:(dot label)*

primitiveExpression
  = doubleLiteral
  / naturalLiteral
  / textLiteral
  / integerLiteral
  / openBrace a:recordTypeOrLiteral closeBrace
    {
      return {
        type: "Record",
        args: [a]
      }
    }
  / openAngle unionTypeOrLiteral closeAngle
  / nonEmptyListLiteral
  / import
  / Bool
  / True
  / False
  / a:identifier
    {
      return { type: "Var", args: [ a ] }
    }
  / openParens a:expression closeParens { return a; }
  
openAngle
  = "<" whitespace

integerLiteral
  = naturalRaw whitespace

textLiteral
  = (doubleQuoteLiteral) whitespace

doubleQuoteLiteral
  = "\"" doubleQuoteChunk* "\""

doubleQuoteChunk
  = [a-zA-Z\-.@ 0-9_,\\]

Bool
  = "Bool" whitespace
    { return { type: "Bool" } }

True
  = "True" whitespace
    { return { type: "True" } }

False
  = "False" whitespace
    { return { type: "False" } }

if
  = "if" whitespace

then
  = "then" whitespace

else
  = "else" whitespace

let
  = "let" whitespace

equal
  = "=" whitespace

in
  = "in" whitespace

endOfLine
  = "\n" / "\r\n"


identifier
  = label (at naturalRaw)?
 
at
  = "@" whitespace

forall
  = ("forall" / "∀") whitespace

recordTypeOrLiteral
  = equal { return {} } 
  / nonEmptyRecordTypeOrLiteral
  / ""

openBrace
  = "{" whitespace

closeBrace
  = "}" whitespace

nonEmptyRecordTypeOrLiteral
  = k:label v:(nonEmptyRecordLiteral / nonEmptyRecordType)
    {
      var fields = {}
      fields[k] = v[0];
      return fields;
    }

nonEmptyRecordLiteral
  = equal a:expression b:(comma label equal expression)*
    {
      return [a, b]
    }

nonEmptyRecordType
  = colon expression (comma expression)*

comma
  = "," whitespace

merge
  = "merge" whitespace

dot
  = "." whitespace

import
  = p:pathHashed t:(as Text)?
    {
      p.asText = t ? true : false;
      return p;
    }

pathHashed
  = p:pathType h:hash? { p.hash = h; return p; }

as
  = "as" whitespace

Text
  = "Text" whitespace

pathType
  = p:file { return { type: "file", path: p } }

file
  = a:fileRaw whitespace { return a; }

fileRaw
  = "/" headPathCharacter pathCharacter*
  / "./" chars:pathCharacter* { return "./" + chars.join(''); }

hash
  = "sha256:" digits:HEXDIG* & { return digits.length() == 64; }

headPathCharacter
  = c:. & { return c != " "; } { return c; }

pathCharacter
  = headPathCharacter / "\\" / "/"

HEXDIG
  = DIGIT / [ABCDEF]

nonEmptyListLiteral
  = openBracket expression (comma expression)* closeBracket

openBracket
  = "[" whitespace

closeBracket
  = "]" whitespace

naturalLiteral
  = "+" naturalRaw whitespace

naturalRaw
  = DIGIT+

unionTypeOrLiteral 
  = nonEmptyUnionTypeOrLiteral / ""

nonEmptyUnionTypeOrLiteral 
  = label
  ( equal expression (bar label colon expression)*
  / colon expression (bar nonEmptyUnionTypeOrLiteral / "")
  )

closeAngle
  = ">" whitespace

bar
  = "|" whitespace

doubleLiteral
  = "-"? DIGIT+ ("." DIGIT+ exponent? / exponent)

exponent
  = "e" ("+" / "-")? DIGIT+
 
lineComment
  = "--" notEndOfLine* endOfLine

notEndOfLine
  = [a-zA-Z ,]

env
  = "env:"
  ( bashEnvironmentVariable
  / '"' posixEnvironmentVariable '"'
  ) whitespace

bashEnvironmentVariable
  = (ALPHA / "_") *(ALPHA / DIGIT / "_")

posixEnvironmentVariable
  = posixEnvironmentVariableCharacter+

posixEnvironmentVariableCharacter =
      "\\"
      ( [abfnrtv] )
    / .
    / .
    / .
    / .

textAppend
  = "++" whitespace
  
or = "||" whitespace
plus = "+" whitespace
and = "&&" whitespace
combine = ("∧" / "/\\") whitespace
times = "*" whitespace
doubleEqual = "==" whitespace
notEqual = "!=" whitespace
