completeExpression
  = whitespace e:expression { return e; }

endOfLine
  = "\n" / "\r\n"

tab
  = "\t"

blockComment
  = "{-" blockCommentContinue

blockCommentChunk
  = blockComment
  / . // TODO %x20-10FFFF
  / tab
  / endOfLine

blockCommentContinue
  = "-}" / blockCommentChunk blockCommentContinue

notEndOfLine
  = [a-zA-Z ,] // TODO %x20-10FFFF
  / tab

lineComment
  = "--" notEndOfLine* endOfLine

whitespaceChunk
  = [ ]
  / tab
  / endOfLine
  / lineComment
  / blockComment

whitespace
  = whitespaceChunk*

ALPHA
  = [a-zA-Z]

DIGIT
  = [0-9]

HEXDIG
  = DIGIT / [ABCDEF]

simpleLabel
  = !reserved
    x:(ALPHA / "_") xs:(ALPHA / DIGIT / [\-/_])*
    { return x + xs.join(''); }

quotedLabel
  = (ALPHA / DIGIT / [\-/_:.])+

label
  = ("`" quotedLabel "`" / l:simpleLabel) whitespace

// TODO
doubleQuoteChunk
  = [a-zA-Z\-.@ 0-9_,\\]

doubleQuoteLiteral
  = "\"" doubleQuoteChunk* "\""

// TODO singleQuoteLiteral

textLiteral
  = (doubleQuoteLiteral /* TODO / singleQuoteLiteral */) whitespace

if                = "if"               whitespace
then              = "then"             whitespace
else              = "else"             whitespace
let               = "let"              whitespace
in                = "in"               whitespace
as                = "as"               whitespace
using             = "using"            whitespace
merge             = "merge"            whitespace
constructors      = "constructors"     whitespace
NaturalFold       = "Natural-fold"     whitespace
NaturalBuild      = "Natural-build"    whitespace
NaturalIsZero     = "Natural-isZero"   whitespace
NaturalEven       = "Natural-even"     whitespace
NaturalOdd        = "Natural-odd"      whitespace
NaturalToInteger  = "Natural-toInteger"whitespace
NaturalShow       = "Natural-show"     whitespace
IntegerShow       = "Integer-show"     whitespace
DoubleShow        = "Double-show"      whitespace
ListBuild         = "List-build"       whitespace
ListFold          = "List-fold"        whitespace
ListLength        = "List-length"      whitespace
ListHead          = "List-head"        whitespace
ListLast          = "List-last"        whitespace
ListIndexed       = "List-indexed"     whitespace
ListReverse       = "List-reverse"     whitespace
OptionalFold      = "Optional-fold"    whitespace
OptionalBuild     = "Optional-build"   whitespace
Bool              = "Bool"             whitespace
Optional          = "Optional"         whitespace
Natural           = "Natural"          whitespace
Integer           = "Integer"          whitespace
Double            = "Double"           whitespace
Text              = "Text"             whitespace
List              = "List"             whitespace
True              = "True"             whitespace
False             = "False"            whitespace
Type              = "Type"             whitespace
Kind              = "Kind"             whitespace

equal         = "="  whitespace
or            = "||" whitespace
plus          = "+"  whitespace
textAppend    = "++" whitespace
listAppend    = "#"  whitespace
and           = "&&" whitespace
times         = "*"  whitespace
doubleEqual   = "==" whitespace
notEqual      = "!=" whitespace
dot           = "."  whitespace
openBrace     = "{"  whitespace
closeBrace    = "}"  whitespace
openBracket   = "["  whitespace
closeBracket  = "]"  whitespace
openAngle     = "<"  whitespace
closeAngle    = ">"  whitespace
bar           = "|"  whitespace
comma         = ","  whitespace
openParens    = "("  whitespace
closeParens   = ")"  whitespace
colon         = ":"  whitespace
at            = "@"  whitespace

combine = ( "∧" / "/\\"    ) whitespace
prefer  = ( "∧" / "//"     ) whitespace
lambda  = ( "λ" / "\\"     ) whitespace
forall  = ( "∀" / "forall" ) whitespace
arrow   = ( "→" / "->"     ) whitespace

exponent
  = "e" ("+" / "-")? DIGIT+

doubleLiteral
  = "-"? DIGIT+ ("." DIGIT+ exponent? / exponent)

naturalRaw
  = DIGIT+

integerLiteral
  = naturalRaw whitespace

naturalLiteral
  = "+" naturalRaw whitespace

identifier
  = label (at naturalRaw)?

// TODO
headPathCharacter
  = c:. & { return c != " "; } { return c; }

pathCharacter
  = headPathCharacter / "\\" / "/"

fileRaw
  = "/" headPathCharacter pathCharacter*
  / "./" chars:pathCharacter* { return "./" + chars.join(''); }

file
  = a:fileRaw whitespace { return a; }

env
  = "env:"
  ( bashEnvironmentVariable
  / '"' posixEnvironmentVariable '"'
  ) whitespace

bashEnvironmentVariable
  = (ALPHA / "_") *(ALPHA / DIGIT / "_")

posixEnvironmentVariable
  = posixEnvironmentVariableCharacter+

posixEnvironmentVariableCharacter =
      "\\"
      ( [abfnrtv] )
    / .
    / .
    / .
    / .

pathType
  = p:file { return { type: "file", path: p } }

hash
  = "sha256:" digits:HEXDIG* & { return digits.length() == 64; }

pathHashed
  = p:pathType h:hash? { p.hash = h; return p; }

import
  = p:pathHashed t:(as Text)?
    {
      p.asText = t ? true : false;
      return p;
    }

expression
  = lambda openParens a:label colon b:expression closeParens arrow c:expression
    {
      return {
        type: "Lambda",
        args: [ a, b, c ]
      };
    }
  / if a:expression then b:expression else c:expression
    {
      return {
        type: "If",
        args: [ a, b, c ]
      }
    }
  / let a:label b:(colon t:expression { return t; })? equal c:expression in d:expression
    {
      return {
        type: "Let",
        args: [a, b, c,d]
      }
    }
  / forall openParens a:label colon b:expression closeParens arrow c:expression
    {
      return {
        type: "Forall",
        args: [a, b, c]
      }
    }
  / operatorExpression arrow expression
  / annotatedExpression

annotatedExpression
  = merge a:selectorExpression b:selectorExpression (colon applicationExpression)?
    {
      return {
        type: "Merge",
        args: [a, b]
      }
    }
  / openBracket (emptyCollection / nonEmptyOptional)
  / a:operatorExpression t:(colon t:expression { return t; })?
    {
      if (t) {
        return {
          type: "Annotate",
          args: [ a,t ]
        }
      } else {
        return a;
      }
    }

emptyCollection
  = closeBracket colon (List / Optional) selectorExpression

nonEmptyOptional
  = expression closeBracket colon Optional selectorExpression

operatorExpression
  = orExpression

orExpression
  = plusExpression (or plusExpression)*

plusExpression
  = textAppendExpression (plus listAppendExpression)*

textAppendExpression
  = listAppendExpression (textAppend listAppendExpression)*

listAppendExpression
  = andExpression (listAppend andExpression)*

andExpression
  = combineExpression (and combineExpression)*

combineExpression
  = preferExpression (combine preferExpression)*

preferExpression =
  e:timesExpression prefers:(prefer timesExpression)*

timesExpression =
  e:equalExpression prefers:(times equalExpression)*

equalExpression =
  e:notEqualExpression prefers:(doubleEqual notEqualExpression)*

notEqualExpression =
  e:applicationExpression prefers:(notEqual applicationExpression)*

applicationExpression
  = c:constructors? args:selectorExpression+

selectorExpression
  = e:primitiveExpression path:(dot label)*

primitiveExpression
  = doubleLiteral
  / naturalLiteral
  / integerLiteral
  / textLiteral
  / openBrace a:recordTypeOrLiteral closeBrace
    {
      return {
        type: "Record",
        args: [a]
      }
    }
  / openAngle unionTypeOrLiteral closeAngle
  / nonEmptyListLiteral
  / import
  / a:identifier
    {
      return { type: "Var", args: [ a ] }
    }
  / NaturalFold
  / NaturalBuild
  / NaturalIsZero
  / NaturalEven
  / NaturalOdd
  / NaturalToInteger
  / NaturalShow
  / IntegerShow
  / DoubleShow
  / ListBuild
  / ListFold
  / ListLength
  / ListHead
  / ListLast
  / ListIndexed
  / ListReverse
  / OptionalFold
  / OptionalBuild
  / Bool
  / Optional
  / Natural
  / Integer
  / Double
  / Text
  / List
  / True
  / False
  / Type
  / Kind
  / openParens a:expression closeParens { return a; }

recordTypeOrLiteral
  = equal { return {} }
  / nonEmptyRecordTypeOrLiteral
  / ""

nonEmptyRecordTypeOrLiteral
  = k:label v:(nonEmptyRecordLiteral / nonEmptyRecordType)
    {
      var fields = {}
      fields[k] = v[0];
      return fields;
    }

nonEmptyRecordType
  = colon expression (comma expression)*

nonEmptyRecordLiteral
  = equal a:expression b:(comma label equal expression)*
    {
      return [a, b]
    }

unionTypeOrLiteral
  = nonEmptyUnionTypeOrLiteral / ""

nonEmptyUnionTypeOrLiteral
  = label
  ( equal expression (bar label colon expression)*
  / colon expression (bar nonEmptyUnionTypeOrLiteral / "")
  )

nonEmptyListLiteral
  = openBracket expression (comma expression)* closeBracket

reserved
  = "let" / "in" // TODO
