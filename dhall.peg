completeExpression
  = whitespace e:expression { return e; }

endOfLine
  = "\u000A" / "\u000D" "\u000A"

tab
  = "\u0009"

blockComment
  = "{-" blockCommentContinue

blockCommentChunk
  = blockComment
  / [\u0020-\uFFFF]
  / tab
  / endOfLine

blockCommentContinue
  = "-}" / blockCommentChunk blockCommentContinue

notEndOfLine
  = [\u0020-\uFFFF]
  / tab

lineComment
  = "--" notEndOfLine* endOfLine

whitespaceChunk
  = [ ]
  / tab
  / endOfLine
  / lineComment
  / blockComment

whitespace
  = whitespaceChunk*

ALPHA
  = [\u0041-\u005A] / [\u0061-\u007A]

DIGIT
  = [\u0030-\u0039]

HEXDIG
  = DIGIT / [ABCDEF]

simpleLabel
  = !reserved
    x:(ALPHA / "_") xs:(ALPHA / DIGIT / [\-/_])*
    { return x + xs.join(''); }

quotedLabel
  = (ALPHA / DIGIT / [\-/_:.])+

label
  = ("`" quotedLabel "`" / l:simpleLabel) whitespace

// TODO
doubleQuoteChunk
  =
      "${" expression "}"
    / "\u005C"
      ( "\u0022"
      / "\u0024"
      / "\u005C"
      / "\u002F"
      / "\u0062"
      / "\u0066"
      / "\u006E"
      / "\u0072"
      / "\u0074"
      / "\u0075"
      )
    / [\u0020-\u0021]
    / [\u0023-\u005B]
    / [\u005D-\uFFFF]

doubleQuoteLiteral
  = "\"" doubleQuoteChunk* "\""

singleQuoteContinue =
      "'''"               singleQuoteContinue
    / "${" expression "}" singleQuoteContinue
    / "''${"              singleQuoteContinue
    / "''"
    / [\u0020-\uFFFF]     singleQuoteContinue
    / tab                 singleQuoteContinue
    / endOfLine           singleQuoteContinue

singleQuoteLiteral = "''" singleQuoteContinue

textLiteral
  = (doubleQuoteLiteral / singleQuoteLiteral) whitespace

if                = "if"               whitespace
then              = "then"             whitespace
else              = "else"             whitespace
let               = "let"              whitespace
in                = "in"               whitespace
as                = "as"               whitespace
using             = "using"            whitespace
merge             = "merge"            whitespace
constructors      = "constructors"     whitespace
NaturalFold       = "Natural/fold"     whitespace
NaturalBuild      = "Natural/build"    whitespace
NaturalIsZero     = "Natural/isZero"   whitespace
NaturalEven       = "Natural/even"     whitespace
NaturalOdd        = "Natural/odd"      whitespace
NaturalToInteger  = "Natural/toInteger"whitespace
NaturalShow       = "Natural/show"     whitespace
IntegerShow       = "Integer/show"     whitespace
DoubleShow        = "Double/show"      whitespace
ListBuild         = "List/build"       whitespace
ListFold          = "List/fold"        whitespace
ListLength        = "List/length"      whitespace
ListHead          = "List/head"        whitespace
ListLast          = "List/last"        whitespace
ListIndexed       = "List/indexed"     whitespace
ListReverse       = "List/reverse"     whitespace
OptionalFold      = "Optional/fold"    whitespace
OptionalBuild     = "Optional/build"   whitespace
Bool              = "Bool"             whitespace
Optional          = "Optional"         whitespace
Natural           = "Natural"          whitespace
Integer           = "Integer"          whitespace
Double            = "Double"           whitespace
Text              = "Text"             whitespace
List              = "List"             whitespace
True              = "True"             whitespace
False             = "False"            whitespace
Type              = "Type"             whitespace
Kind              = "Kind"             whitespace

equal         = "="  whitespace
or            = "||" whitespace
plus          = "+"  whitespace
textAppend    = "++" whitespace
listAppend    = "#"  whitespace
and           = "&&" whitespace
times         = "*"  whitespace
doubleEqual   = "==" whitespace
notEqual      = "!=" whitespace
dot           = "."  whitespace
openBrace     = "{"  whitespace
closeBrace    = "}"  whitespace
openBracket   = "["  whitespace
closeBracket  = "]"  whitespace
openAngle     = "<"  whitespace
closeAngle    = ">"  whitespace
bar           = "|"  whitespace
comma         = ","  whitespace
openParens    = "("  whitespace
closeParens   = ")"  whitespace
colon         = ":"  whitespace
at            = "@"  whitespace

combine = ( "∧" / "/\\"    ) whitespace
prefer  = ( "∧" / "//"     ) whitespace
lambda  = ( "λ" / "\\"     ) whitespace
forall  = ( "∀" / "forall" ) whitespace
arrow   = ( "→" / "->"     ) whitespace

exponent
  = "e" ("+" / "-")? DIGIT+

doubleLiteral
  = "-"? DIGIT+ ("." DIGIT+ exponent? / exponent)

naturalRaw
  = DIGIT+

integerLiteral
  = naturalRaw whitespace

naturalLiteral
  = "+" naturalRaw whitespace

identifier
  = label (at naturalRaw)?

headPathCharacter =
      [\u0021-\u0027]
    / [\u002A-\u002B]
    / [\u002D-\u002E]
    / [\u0030-\u003B]
    / "\u003D"
    / [\u003F-\u005A]
    / [\u005E-\u007A]
    / "\u007C"
    / "\u007E"

pathCharacter
  = headPathCharacter / "\\" / "/"

fileRaw
  = "/" headPathCharacter pathCharacter*
  / "./" chars:pathCharacter* { return "./" + chars.join(''); }
  / "../" pathCharacter*
  / "~/"  pathCharacter*

file
  = a:fileRaw whitespace { return a; }

scheme =
  "http" "s"?

httpRaw = scheme "://" authority pathAbempty ("?" query)? ("#" fragment)?

// NOTE: Backtrack if parsing the optional user info prefix fails
authority = (userinfo "@")? host (":" port)?

userinfo = ( unreserved / pctEncoded / subDelims / ":" )*

host = IPLiteral / IPv4address / regName

port = DIGIT*

IPLiteral = "[" ( /* IPv6address  / */ IPvFuture  ) "]"

IPvFuture = "v" HEXDIG* "." ( unreserved / subDelims / ":" )+

// TODO
// IPv6address

// h16 = 1*4HEXDIG

// ls32 = ( h16 ":" h16 ) / IPv4address

IPv4address = decOctet "." decOctet "." decOctet "." decOctet

// NOTE: Backtrack when parsing these alternatives and try them in reverse order
// TODO
decOctet = DIGIT
//          / %x31-39 DIGIT      ; 10-99
//          / "1" 2DIGIT         ; 100-199
//          / "2" %x30-34 DIGIT  ; 200-249
//          / "25" %x30-35       ; 250-255

regName = ( unreserved / pctEncoded / subDelims )*

pathAbempty = ( "/" segment )*

segment = pchar*

pchar = unreserved / pctEncoded / subDelims / ":" / "@"

query = ( pchar / "/" / "?" )*

fragment = ( pchar / "/" / "?" )*

pctEncoded = "%" HEXDIG HEXDIG

unreserved  = ALPHA / DIGIT / "-" / "." / "_" / "~"

subDelims = "!" / "$" / "&" / "'" / "(" / ")" / "*" / "+" / "," / ";" / "="

http = httpRaw whitespace (using pathHashed)?

env
  = "env:"
  ( bashEnvironmentVariable
  / '"' posixEnvironmentVariable '"'
  ) whitespace

bashEnvironmentVariable
  = (ALPHA / "_") *(ALPHA / DIGIT / "_")

posixEnvironmentVariable
  = posixEnvironmentVariableCharacter+

posixEnvironmentVariableCharacter =
      "\\"
      ( [abfnrtv] )
    / .
    / .
    / .
    / .

pathType
  = p:file { return { type: "file", path: p } }
  / http
  / env

hash
  = "sha256:" digits:HEXDIG* & { return digits.length() == 64; }

pathHashed
  = p:pathType h:hash? { p.hash = h; return p; }

import
  = p:pathHashed t:(as Text)?
    {
      p.asText = t ? true : false;
      return p;
    }

expression
  = lambda openParens a:label colon b:expression closeParens arrow c:expression
    {
      return {
        type: "Lambda",
        args: [ a, b, c ]
      };
    }
  / if a:expression then b:expression else c:expression
    {
      return {
        type: "If",
        args: [ a, b, c ]
      }
    }
  / let a:label b:(colon t:expression { return t; })? equal c:expression in d:expression
    {
      return {
        type: "Let",
        args: [a, b, c,d]
      }
    }
  / forall openParens a:label colon b:expression closeParens arrow c:expression
    {
      return {
        type: "Forall",
        args: [a, b, c]
      }
    }
  / operatorExpression arrow expression
  / annotatedExpression

annotatedExpression
  = merge a:selectorExpression b:selectorExpression (colon applicationExpression)?
    {
      return {
        type: "Merge",
        args: [a, b]
      }
    }
  / openBracket (emptyCollection / nonEmptyOptional)
  / a:operatorExpression t:(colon t:expression { return t; })?
    {
      if (t) {
        return {
          type: "Annotate",
          args: [ a,t ]
        }
      } else {
        return a;
      }
    }

emptyCollection
  = closeBracket colon (List / Optional) selectorExpression

nonEmptyOptional
  = expression closeBracket colon Optional selectorExpression

operatorExpression
  = orExpression

orExpression
  = plusExpression (or plusExpression)*

plusExpression
  = textAppendExpression (plus listAppendExpression)*

textAppendExpression
  = listAppendExpression (textAppend listAppendExpression)*

listAppendExpression
  = andExpression (listAppend andExpression)*

andExpression
  = combineExpression (and combineExpression)*

combineExpression
  = preferExpression (combine preferExpression)*

preferExpression =
  e:timesExpression prefers:(prefer timesExpression)*

timesExpression =
  e:equalExpression prefers:(times equalExpression)*

equalExpression =
  e:notEqualExpression prefers:(doubleEqual notEqualExpression)*

notEqualExpression =
  e:applicationExpression prefers:(notEqual applicationExpression)*

applicationExpression
  = c:constructors? args:selectorExpression+

selectorExpression
  = e:primitiveExpression path:(dot label)*

primitiveExpression
  = doubleLiteral
  / naturalLiteral
  / integerLiteral
  / textLiteral
  / openBrace a:recordTypeOrLiteral closeBrace
    {
      return {
        type: "Record",
        args: [a]
      }
    }
  / openAngle unionTypeOrLiteral closeAngle
  / nonEmptyListLiteral
  / import
  / a:identifier
  {
    return { type: "Var", args: [ a ] }
  }
  / NaturalFold
  / NaturalBuild
  / NaturalIsZero
  / NaturalEven
  / NaturalOdd
  / NaturalToInteger
  / NaturalShow
  / IntegerShow
  / DoubleShow
  / ListBuild
  / ListFold
  / ListLength
  / ListHead
  / ListLast
  / ListIndexed
  / ListReverse
  / OptionalFold
  / OptionalBuild
  / Bool
  / Optional
  / Natural
  / Integer
  / Double
  / Text
  / List
  / True
  / False
  / Type
  / Kind
  / openParens a:expression closeParens { return a; }

recordTypeOrLiteral
  = equal { return {} }
  / nonEmptyRecordTypeOrLiteral
  / ""

nonEmptyRecordTypeOrLiteral
  = k:label v:(nonEmptyRecordLiteral / nonEmptyRecordType)
    {
      var fields = {}
      fields[k] = v[0];
      return fields;
    }

nonEmptyRecordType
  = colon expression (comma expression)*

nonEmptyRecordLiteral
  = equal a:expression b:(comma label equal expression)*
    {
      return [a, b]
    }

unionTypeOrLiteral
  = nonEmptyUnionTypeOrLiteral / ""

nonEmptyUnionTypeOrLiteral
  = label
  ( equal expression (bar label colon expression)*
  / colon expression (bar nonEmptyUnionTypeOrLiteral / "")
  )

nonEmptyListLiteral
  = openBracket expression (comma expression)* closeBracket

reserved
  = "if" / "then" / "else" / "let" / "in" / "as" / "using" / "merge" / "constructors" / "Natural/fold" / "Natural/build" / "Natural/isZero" / "Natural/even" / "Natural/odd" / "Natural/toInteger" / "Natural/show" / "Integer/show" / "Double/show" / "List/build" / "List/fold" / "List/length" / "List/head" / "List/last" / "List/indexed" / "List/reverse" / "Optional/fold" / "Optional/build" / "Bool" / "Optional" / "Natural" / "Integer" / "Double" / "Text" / "List" / "True" / "False" / "Type" / "Kind"
